// ============================================
// KERNEL 1: Generate Vertices
// ============================================
kernel GenerateVertices(
    scalarField: 3D texture,
    dimensions: int3,
    vertices: output buffer,        // pre-allocated: dimensions.x * y * z
    vertexValid: output buffer,     // bool array, same size
    vertexIndices: output buffer    // will store compacted indices
):
    // Each thread handles one cell
    threadId = getThreadId3D()
    cellX = threadId.x
    cellY = threadId.y
    cellZ = threadId.z
    
    if cellX >= dimensions.x - 1 or 
       cellY >= dimensions.y - 1 or 
       cellZ >= dimensions.z - 1:
        return
    
    // Flatten 3D index to 1D
    cellIndex = cellX + cellY * dimensions.x + cellZ * dimensions.x * dimensions.y
    
    // Define the 8 corners of this cell
    corners = [
        (cellX,   cellY,   cellZ),
        (cellX+1, cellY,   cellZ),
        (cellX+1, cellY+1, cellZ),
        (cellX,   cellY+1, cellZ),
        (cellX,   cellY,   cellZ+1),
        (cellX+1, cellY,   cellZ+1),
        (cellX+1, cellY+1, cellZ+1),
        (cellX,   cellY+1, cellZ+1)
    ]
    
    // Define the 12 edges (pairs of corner indices)
    edges = [
        (0,1), (1,2), (2,3), (3,0),  // bottom face
        (4,5), (5,6), (6,7), (7,4),  // top face
        (0,4), (1,5), (2,6), (3,7)   // vertical edges
    ]
    
    // Find all edge crossings
    crossingSum = float3(0, 0, 0)
    crossingCount = 0
    
    for each edge in edges:
        p0 = corners[edge.start]
        p1 = corners[edge.end]
        
        v0 = sampleScalarField(scalarField, p0)
        v1 = sampleScalarField(scalarField, p1)
        
        // Check for sign change (surface crossing)
        if sign(v0) != sign(v1):
            // Linear interpolation
            t = v0 / (v0 - v1)
            crossingPoint = lerp(p0, p1, t)
            
            crossingSum += crossingPoint
            crossingCount++
    
    // If this cell contains the surface, create vertex
    if crossingCount > 0:
        vertexPos = crossingSum / float(crossingCount)
        vertices[cellIndex] = vertexPos
        vertexValid[cellIndex] = true
    else:
        vertexValid[cellIndex] = false


// ============================================
// KERNEL 2: Compute Prefix Sum (Parallel Scan)
// ============================================
// This computes compacted vertex indices
// Standard parallel prefix sum algorithm (e.g., Blelloch scan)
kernel PrefixSum(
    vertexValid: input buffer,
    vertexIndices: output buffer,   // compacted indices
    totalVertices: output int        // total count
):
    // Use standard GPU prefix sum algorithm
    // Each vertexIndices[i] will contain the compacted index
    // for cell i if it has a valid vertex
    
    // Implementation: Use work-efficient parallel scan
    // or library function like CUB/Thrust on CUDA


// ============================================
// KERNEL 3: Compact Vertices
// ============================================
kernel CompactVertices(
    vertices: input buffer,
    vertexValid: input buffer,
    vertexIndices: input buffer,
    compactedVertices: output buffer
):
    threadId = getThreadId1D()
    
    if vertexValid[threadId]:
        compactedIndex = vertexIndices[threadId]
        compactedVertices[compactedIndex] = vertices[threadId]


// ============================================
// KERNEL 4: Generate Faces
// ============================================
kernel GenerateFaces(
    dimensions: int3,
    vertexValid: input buffer,
    vertexIndices: input buffer,
    faces: output buffer,           // pre-allocated: dimensions * 3 faces * 4 verts
    faceValid: output buffer,       // which face slots are used
    faceCount: atomic counter
):
    threadId = getThreadId3D()
    cellX = threadId.x
    cellY = threadId.y
    cellZ = threadId.z
    
    if cellX >= dimensions.x - 1 or 
       cellY >= dimensions.y - 1 or 
       cellZ >= dimensions.z - 1:
        return
    
    cellIndex = cellX + cellY * dimensions.x + cellZ * dimensions.x * dimensions.y
    
    // Skip if this cell has no vertex
    if not vertexValid[cellIndex]:
        return
    
    v0 = vertexIndices[cellIndex]
    
    // Each cell can generate up to 3 quad faces
    // We'll write them to a pre-calculated offset
    baseFaceIndex = cellIndex * 3
    localFaceCount = 0
    
    // Helper function to get cell index
    function getCellIndex(x, y, z):
        return x + y * dimensions.x + z * dimensions.x * dimensions.y
    
    // Face 1: Right-Front (X-Y plane)
    if cellX + 1 < dimensions.x - 1 and cellY + 1 < dimensions.y - 1:
        idx1 = getCellIndex(cellX + 1, cellY, cellZ)
        idx2 = getCellIndex(cellX + 1, cellY + 1, cellZ)
        idx3 = getCellIndex(cellX, cellY + 1, cellZ)
        
        if vertexValid[idx1] and vertexValid[idx2] and vertexValid[idx3]:
            v1 = vertexIndices[idx1]
            v2 = vertexIndices[idx2]
            v3 = vertexIndices[idx3]
            
            faceIdx = baseFaceIndex + localFaceCount
            faces[faceIdx * 4 + 0] = v0
            faces[faceIdx * 4 + 1] = v1
            faces[faceIdx * 4 + 2] = v2
            faces[faceIdx * 4 + 3] = v3
            faceValid[faceIdx] = true
            localFaceCount++
    
    // Face 2: Right-Top (X-Z plane)
    if cellX + 1 < dimensions.x - 1 and cellZ + 1 < dimensions.z - 1:
        idx1 = getCellIndex(cellX + 1, cellY, cellZ)
        idx2 = getCellIndex(cellX + 1, cellY, cellZ + 1)
        idx3 = getCellIndex(cellX, cellY, cellZ + 1)
        
        if vertexValid[idx1] and vertexValid[idx2] and vertexValid[idx3]:
            v1 = vertexIndices[idx1]
            v2 = vertexIndices[idx2]
            v3 = vertexIndices[idx3]
            
            faceIdx = baseFaceIndex + localFaceCount
            faces[faceIdx * 4 + 0] = v0
            faces[faceIdx * 4 + 1] = v1
            faces[faceIdx * 4 + 2] = v2
            faces[faceIdx * 4 + 3] = v3
            faceValid[faceIdx] = true
            localFaceCount++
    
    // Face 3: Front-Top (Y-Z plane)
    if cellY + 1 < dimensions.y - 1 and cellZ + 1 < dimensions.z - 1:
        idx1 = getCellIndex(cellX, cellY + 1, cellZ)
        idx2 = getCellIndex(cellX, cellY + 1, cellZ + 1)
        idx3 = getCellIndex(cellX, cellY, cellZ + 1)
        
        if vertexValid[idx1] and vertexValid[idx2] and vertexValid[idx3]:
            v1 = vertexIndices[idx1]
            v2 = vertexIndices[idx2]
            v3 = vertexIndices[idx3]
            
            faceIdx = baseFaceIndex + localFaceCount
            faces[faceIdx * 4 + 0] = v0
            faces[faceIdx * 4 + 1] = v1
            faces[faceIdx * 4 + 2] = v2
            faces[faceIdx * 4 + 3] = v3
            faceValid[faceIdx] = true
            localFaceCount++


// ============================================
// KERNEL 5: Compact Faces
// ============================================
kernel CompactFaces(
    faces: input buffer,
    faceValid: input buffer,
    faceIndices: input buffer,      // from prefix sum on faceValid
    compactedFaces: output buffer
):
    threadId = getThreadId1D()
    
    if faceValid[threadId]:
        compactedIndex = faceIndices[threadId]
        // Copy all 4 vertices of the quad
        compactedFaces[compactedIndex * 4 + 0] = faces[threadId * 4 + 0]
        compactedFaces[compactedIndex * 4 + 1] = faces[threadId * 4 + 1]
        compactedFaces[compactedIndex * 4 + 2] = faces[threadId * 4 + 2]
        compactedFaces[compactedIndex * 4 + 3] = faces[threadId * 4 + 3]


// ============================================
// HOST CODE: Main Pipeline
// ============================================
function SurfaceNetsGPU(scalarField, dimensions):
    totalCells = dimensions.x * dimensions.y * dimensions.z
    maxFaces = totalCells * 3
    
    // Allocate GPU buffers
    vertices = allocateBuffer(totalCells * sizeof(float3))
    vertexValid = allocateBuffer(totalCells * sizeof(bool))
    vertexIndices = allocateBuffer(totalCells * sizeof(int))
    
    faces = allocateBuffer(maxFaces * 4 * sizeof(int))
    faceValid = allocateBuffer(maxFaces * sizeof(bool))
    faceIndices = allocateBuffer(maxFaces * sizeof(int))
    
    // Step 1: Generate vertices (parallel)
    launch GenerateVertices with gridDim=(dimensions.x/8, dimensions.y/8, dimensions.z/8),
                                 blockDim=(8, 8, 8)
    
    // Step 2: Compute prefix sum for vertex compaction
    launch PrefixSum on vertexValid -> vertexIndices, totalVertexCount
    
    // Step 3: Compact vertices
    compactedVertices = allocateBuffer(totalVertexCount * sizeof(float3))
    launch CompactVertices with threads=totalCells
    
    // Step 4: Generate faces (parallel)
    launch GenerateFaces with gridDim=(dimensions.x/8, dimensions.y/8, dimensions.z/8),
                             blockDim=(8, 8, 8)
    
    // Step 5: Compute prefix sum for face compaction
    launch PrefixSum on faceValid -> faceIndices, totalFaceCount
    
    // Step 6: Compact faces
    compactedFaces = allocateBuffer(totalFaceCount * 4 * sizeof(int))
    launch CompactFaces with threads=maxFaces
    
    return compactedVertices, compactedFaces
